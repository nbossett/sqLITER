{\rtf1\ansi\ansicpg1252\deff0\deftab560{\fonttbl{\f0\froman\fprq2\fcharset0 Arial;}{\f1\froman\fprq2\fcharset0 Liberation Serif;}}
{\colortbl ;\red0\green0\blue0;\red0\green0\blue255;\red0\green0\blue128;}
{\*\generator Msftedit 5.41.21.2510;}\viewkind4\uc1\pard\nowidctlpar\sa200\sl276\slmult1\qc\cf1\lang9\kerning1\b\f0\fs40 sqLITER Documentation\lang1033\b0\f1\fs24\par
\lang9\b\f0\fs32 (V0.6)\lang1033\b0\f1\fs24\par
\lang9\b\f0\fs32\par
\pard\nowidctlpar\sa200\sl276\slmult1 Summary\lang1033\b0\f1\fs24\par
\pard\nowidctlpar\li562\sa140\sl288\slmult1\lang9\f0\fs20 This documentation consists of:\lang1033\f1\fs24\par
\pard\nowidctlpar\fi-360\li720\sa86\sl276\slmult1\cf0\kerning0\f0\fs20\bullet\tab\cf1\lang9\kerning1 Installation of sqLITER\lang1033\f1\fs24\par
\cf0\kerning0\f0\fs20\bullet\tab\cf1\lang9\kerning1 Overview of Objects and Calls\lang1033\f1\fs24\par
\cf0\kerning0\f0\fs20\bullet\tab\cf1\lang9\kerning1 Overview of Typical Use\lang1033\f1\fs24\par
\cf0\kerning0\f0\fs20\bullet\tab\cf1\lang9\kerning1 Details of API\lang1033\f1\fs24\par
\cf0\kerning0\f0\fs20\bullet\tab\cf1\lang9\kerning1 Example Use of API\lang1033\f1\fs24\par
\cf0\kerning0\f0\fs20\bullet\tab\cf1\lang9\kerning1 Feature Requests and Bug Reports\lang1033\f1\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\par
\lang9\b\f0\fs32 Installation of sqLITER\lang1033\b0\f1\fs24\par
\pard\nowidctlpar\fi-360\li720\sa200\sl276\slmult1\cf0\kerning0  1.\tab\cf1\lang9\kerning1\f0\fs20 Download one of the precompiled binaries of SQLite for your machine, or compile and install SQLite from source.  \lang1033\f1\fs24{\field{\*\fldinst{HYPERLINK "http://www.sqlite.org/" }}{\fldrslt{\cf3\lang9\ul\f0\fs20 http://www.sqlite.org}}}\cf1\lang1033\ulnone\f1\fs24\par
\cf0\kerning0  2.\tab\cf1\lang9\kerning1\f0\fs20 Download the sqLiter files from \lang1033\f1\fs24{\field{\*\fldinst{HYPERLINK "http://www.sqliter.org/" }}{\fldrslt{\cf3\lang9\ul\f0\fs20 http://www.sqliter.org}}}\cf1\ulnone\f0\fs20 .\lang1033\f1\fs24\par
\cf0\kerning0  3.\tab\cf1\lang9\kerning1\f0\fs20 Unzip and install the sqLITER files in your project.\lang1033\f1\fs24\par
\cf0\kerning0  4.\tab\cf1\lang9\kerning1\f0\fs20 Include the sqLiter header to your C++ project using the following code: #include "sqliter/src/sqliter.h"\lang1033\f1\fs24\par
\cf0\kerning0  5.\tab\cf1\lang9\kerning1\f0\fs20 All other required files will be called by the sqLITER wrapper.\lang1033\f1\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\par
\lang9\b\f0\fs32 Overview of Objects and Calls\lang1033\b0\f1\fs24\par
\pard\nowidctlpar\li560\sa140\sl288\slmult1\lang9\f0\fs20 A user of the library will use the principal class CSQLiter.  Several other helper classes are provided by that object for setting options and storing data, but none of them need be created by the library user.  A CSQLiter class instance represents a connection to a database file and it is possible to have multiple connections in the same application or within several different applications.\lang1033\f1\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\par
\lang9\b\f0\fs32 Overview of Typical Use\lang1033\b0\f1\fs24\par
\pard\nowidctlpar\li560\sa140\sl288\slmult1\lang9\f0\fs20 A typical database usage will begin by opening (or creating) a database, running commands written in SQL against that database, and closing the database connection afterwards.  For each statement, results other than an error code may or may not be provided.\lang1033\f1\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\lang9\f0 Opening a Database\lang1033\f1\par
\pard\nowidctlpar\li560\sa140\sl288\slmult1\lang9\f0\fs20 You can open or create a new database by invoking \b opendb()\b0  or \b createdb()\b0  on a CSQLiter instance.  \lang1033\f1\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\lang9\f0 Running SQL Statements\lang1033\f1\par
\pard\nowidctlpar\li560\sa140\sl288\slmult1\lang9\f0\fs20 Once you have an open database connection: \lang1033\f1\fs24\par
\pard\nowidctlpar\fi-360\li720\sa200\sl276\slmult1\cf0\kerning0  1.\tab\cf1\lang9\kerning1\f0\fs20 Set the SQL command to be executed, such as "SELECT first_name, last_name FROM client;"\lang1033\f1\fs24\par
\cf0\kerning0  2.\tab\cf1\lang9\kerning1\f0\fs20 Bind any required input parameters\lang1033\f1\fs24\par
\cf0\kerning0  3.\tab\cf1\lang9\kerning1\f0\fs20 Specify the number, type, and order of expected result data rows.  An example would be to expect two TEXT values for the above SQL statement.\lang1033\f1\fs24\par
\cf0\kerning0  4.\tab\cf1\lang9\kerning1\f0\fs20 Executing the statement involves either the runstep or runsinglestepstatement functions depending on whether 0, 1, or a larger number of rows could be a correct result data set of executing the statement.  The cases of 0 and 1 are provided for convenience in the case of statements known to yield no results (such as INSERT) or to handle cases such as a SELECT by unique id in which anything other than 0 or 1 result rows constitutes an error. \lang1033\f1\fs24\par
\cf0\kerning0  5.\tab\cf1\lang9\kerning1\f0\fs20 Results, if any, from executing the statement are available immediately after executing a step of the statement.  A result row is a vector of cells which identify the type and value of data being returned.\lang1033\f1\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\lang9\f0 Closing the Database\lang1033\f1\par
\pard\nowidctlpar\li560\sa140\sl288\slmult1\lang9\f0\fs20 The database is closed by invoking the \b closedb()\b0  function.\lang1033\f1\fs24\par
\pard\nowidctlpar\sl276\slmult1\lang9\f0\fs20\par
\pard\nowidctlpar\sa200\sl276\slmult1\lang1033\f1\fs24\par
\lang9\b\f0\fs32 Details of API \lang1033\b0\f1\fs24\par
\pard\nowidctlpar\li560\sa200\sl276\slmult1\lang9\f0\fs20 The header file sqliter.h should be consulted for full details of calling parameters.  This documentation describes families of similar calls.\lang1033\f1\fs24\par
\pard\nowidctlpar\lang9\f0 Database Access and Management \lang1033\f1\par
\par
\pard\nowidctlpar\li560\lang9\b\f0\fs20 openexistingdb( string \ldblquote path/to/database/file\rdblquote  )\b0  accepts the path of a database file; The return result reflects whether or not it was opened successfully.  Note that opening a database file does not guarantee that write access has been obtained.\lang1033\f1\fs24\par
\lang9\f0\fs20\par
\b createdb( string \ldblquote path/to/database/file\rdblquote  )\b0  will create a new database.  The call will fail if a database already exists at that path.\lang1033\f1\fs24\par
\lang9\f0\fs20\par
\pard\nowidctlpar\li560\sa200\sl276\slmult1\b removedatabase( string \ldblquote path/to/database/file\rdblquote  )\b0  will delete the specified database.\lang1033\f1\fs24\par
\lang9\b\f0\fs20 getdbhandle()\b0  returns the raw database handle\lang1033\f1\fs24\par
\lang9\b\f0\fs20 setdbhandle( dbhandle \ldblquote raw_database_handle\rdblquote )\b0  sets a raw database handle\lang1033\f1\fs24\par
\lang9\b\f0\fs20 closedb()\b0  ends a database session.  There is no return value.\lang1033\f1\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\par
\lang9\f0 Data and Transactions\lang1033\f1\par
\pard\nowidctlpar\li560\sa200\sl276\slmult1\lang9\b\f0\fs20 setsql( string \ldblquote sql statement\rdblquote  ) \b0 assigns the SQL language statement(s) to execute, such as "SELECT first_name from client;"\lang1033\f1\fs24\par
\lang9\b\f0\fs20 bindstr(), bindint(), bindfloat(), bindblob(), bindnull() \b0 assigns values to a SQL statement, such as :lastname in "SELECT first_name from client o WHERE o.last_name = :lastname;"\lang1033\f1\fs24\par
\lang9\b\f0\fs20 pushvaltype(), pushvaltypesout() \b0 tells the SQLite database what type of data to expect and return (number, order, and type) in each row of SELECT results.\lang1033\f1\fs24\par
\lang9\b\f0\fs20 runstep() \b0 executes a step in a statement which can have an arbitrary number of result rows, including the zero or one cases covered by \b runsinglestepstatement()\b0 .\lang1033\f1\fs24\par
\lang9\b\f0\fs20 runsinglestepstatement() \b0 executes a statement in which the user believes any number of rows returned more than either zero or one (user's choice for each call) is an error.  Examples are INSERT's (doesn't return a row at all) and SELECTs by an id which is supposed to be unique and which therefore shouldn't return more than one row.\lang1033\f1\fs24\par
\lang9\b\f0\fs20 closestatement() \b0 tells sqLITER to halt running of the existing statement, but not to entirely clear it.  The SQL statement itself is retained, which saves time if the user wants to run a series of statements which share an identical \b setsql()\b0  call but which differ in terms of input values bound.  Another use is to release a lock when the application has received some row results but does not intend to retrieve the rest.\lang1033\f1\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\par
\lang9\f0 Testing, Logging, and Debug\lang1033\f1\par
\pard\nowidctlpar\li560\sa200\sl276\slmult1\lang9\b\f0\fs20 startlog()\b0 , \b stoplog() \b0 starts and stops more detailed logging of calls and results.\lang1033\f1\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\par
\lang9\b\f0\fs32 Example Use of API\lang1033\b0\f1\fs24\par
\pard\nowidctlpar\li560\sa200\sl276\slmult1\lang9\f0\fs20 The following example C++ code creates a database of 2D points, adds the points (1,2) and (3,5) and then retrieves and displays those points.  Note that running the demonstration code twice without deleting the database file will fail because the database will already exist, causing the createdb call to fail.\lang1033\f1\fs24\par
\pard\nowidctlpar\li560\sl276\slmult1\par
\pard\nowidctlpar\li562\sa200\sl240\slmult1\lang9\f0\fs20 #include <string>\par
#include <iostream>\par
\par
#include "../../src/sqliter.h"\par
\par
int main() \{\par
csqliter db;\par
\par
std::string str1;\par
int tmpint;\par
dbresulttype rval;\par
int i;\par
\par
\tab //create a new database\par
\tab rval = db.createdb("test.db");\par
\tab if (rval != successdb) \{\par
\tab\tab std::cout << "Failed to create database.  Perhaps it already exists from a previous run?\\r\\n";\par
\tab\tab return(1);\par
\tab\}\par
\tab\par
\tab //create a table within the database consisting of 2D integer points\par
\tab db.setsql("CREATE TABLE point2d "\par
\tab\tab "(point2d_id INTEGER PRIMARY KEY AUTOINCREMENT, "\par
\tab\tab "x INTEGER, "\par
\tab\tab "y INTEGER);");\par
\tab rval = db.runsinglestepstatement();\par
\tab if (rval != successdb) \{\par
\tab\tab return(2);\par
\tab\}\par
\tab //put the point (1,2) into the table\par
\tab db.setsql("INSERT INTO point2d "\par
\tab\tab "(x, y) VALUES "\par
\tab\tab "(:x, :y);");\par
\tab db.bindint("x",1);\par
\tab db.bindint("x",2);\par
\tab rval = db.runsinglestepstatement();\par
\tab if (rval != successdb) \{\par
\tab\tab return(3);\par
\tab\}\par
\tab //put the point (3,5) into the database\par
\tab db.setsql("INSERT INTO point2d "\par
\tab\tab "(x, y) VALUES "\par
\tab\tab "(:x, :y);");\par
\tab db.bindint("x",3);\par
\tab db.bindint("y",5);\par
\tab rval = db.runsinglestepstatement();\par
\tab if (rval != successdb) \{\par
\tab\tab return(3);\par
\tab\}\par
\tab //retrieve and display all of the points in the table\tab\par
\tab db.setsql("SELECT x, y FROM point2d;");\par
\tab db.pushvaltypesout(intdbval, intdbval); //tell SQLiter to expect each row of results to consist of two integers\par
\tab while (db.runstep() == rowresultdb) \{\par
\tab\tab std::cout << "point:"\par
\tab\tab << db.rowdata[0].ival << "\\t"\par
\tab\tab << db.rowdata[1].ival << "\\n";\par
\tab\}\par
\tab //close the database\par
\tab db.closedb();\par
\tab std::cout << "basic example run successfully\\r\\n";\par
\}\lang1033\f1\fs24\par
\pard\nowidctlpar\sa200\sl276\slmult1\lang9\b\f0\fs32 Feature Requests and Bug Reports\lang1033\b0\f1\fs24\par
\pard\nowidctlpar\li560\sa200\sl276\slmult1\lang9\f0\fs20 Please submit all feature requests and bug reports to nbossett@pierb.com.\lang1033\f1\fs24\par
}
 